[{"title":"C++复习/1.0/C++的运行_C++编译器的运行_C++链接器的运行","url":"/2025/11/16/C-复习-1-0-C-的运行-C-编译器的运行-C-链接器的运行/","content":"\n## C++\n## 重构/复习\n\n### Part1  c++是如何工作的\n\nInclude 找到一个文件拷贝到现在这个文件里（在编译前）\n\nMain这个函数比较特殊，没有返回值时，默认返回0，仅限此函数\n\n<<重载运算符，也是类似一个函数，也有参数\n例如std::cout<<”666”<<std::endl里面的666就是参数\n或者另一层含义是把字符串666推（push）到cout流中，再打印到终端，再推送一个行结束符\n\nCin.get()是等我们按下enter键在前往下一条命令前等待，这时程序暂停执行，直到按下回车就继续执行\n\n#### 怎么把它转换成一个二进制文件？\n\n【1】预处理。（其实也算是编译的一部分）编译器先处理include（预处理语句），把需要的文件copy进来，你就可以使用这些文件包含的内容了\n\n【2】编译。预处理完就开始编译了，转化为实际机械代码\n\t1.此时你可以根据你的编译器选择多种编译模式或规则（rules），例如debug模式（会更慢，因为很多优化被关掉了，但好处是可以调试代码），release模式（），编译目标平台x86（代表编译成windows32位），x64，安卓的目标平台等等\n\t2.头文件不会被编译，cpp被编译，因为预处理时头文件内容已经含进来了，cpp被编译的时候放进来的文件一起被编译了\n\t3.每个cpp都被编译成一个目标文件（object file）.obj，对于每一个c++文件，都会生成一个obj。\n\n【3】链接。把cpp和obj合成一个可执行文件，则需要link，也就是链接（将所有的obj粘文件合在一起成为一个exe文件）\n\t1.单独编译文件时，并未link。Build时，linker会找到正确的各个文件，将其下的内容如函数定义等导入到log函数里，找不到定义就会出现link error（看起来挺吓人的...）\n\n#### 为了保证代码干净整洁，可以把函数装载到其他文件\n\n\t因为c++中任何符号都需要声明，函数也一样，所以各子文件尽量也要包含头文件，main文件中也要声明函数\n\n`（声明的意思是这个东西是存在的，不一定要有具体内容。如void log（。。。）；这也是函数签名，这样告诉它有这个函数/东西。至于待会要用的时候再找（link等等）。定义的意思是这个东西到底是什么，是怎么样的。就像void log（。。。）{。。。。}）`\n\n\n\n### Part2 c++编译器是如何工作的\n\n获取源文件并输出一个obj文件（包含机器代码以及其他我们定义的常数数据）\nC++与java不同，命名不被严格规定，文件只是提供给编译器源代码的一种方式，而其后缀就是告诉编译器该怎么处理这个文件\n\n翻译单元\n一个cpp文件不一定要等于一个翻译单元，当制作大型项目时，很多cpp文件合在一起也可以称作一个翻译单元\n\n编译的第一阶段\n预处理\n\n编译器遍历预处理语句并对其进行处理，如include，define，if，pragma。。。\n\n#include，编译器打开那个文件，阅读他的所有内容，再粘贴到你写的文件里include相应的位置。所以，它不一定要放在头部，也可穿插在代码行中，仅仅是粘贴内容后再编译没问题就行了。\n\n#define则是搜索后面的那个东西，将它出现的地方替换为末尾那个内容\n例如#define INTER int，对的然后之后的INTER都会被替换为”int“字符，再编译\n\n#if 1，意思是if为真，0就为假，相当于被禁用，再在结尾加个#endif就可以使用。\n\nObj内部是二进制形式，你也可以转换成汇编代码去看。\n\n汇编里函数跟着的一大串随机字符是它的签名，用于唯一定位。\n\n当然优化时也会自动删除无用的函数，追求speed。\n\n\n\n### Part3 c++链接器是如何工作的\n\n从源文件转化为可执行文件，第一阶段是编译源文件，第二阶段就是链接，其主要焦点是找到每个符号和函数在哪里，再把它们连接起来。它也将拉进我们可能用到的其他库，像是c运行时库，c++标准库，平台api等等。\n有静态链接和动态链接，不过留到其他篇目再讲。\n\n但记住，每个文件被编译成一个单独的目标文件，一个翻译单元，他们之间没有关系，不能交互。即使没有其他文件，库通常会在main函数设置入口，（你也可以自定义入口点）进行链接，换句话说应用就是从这里开始run的。\n\nVs里\nC开头的错误代码表示错误出现在编译阶段\nLnk开头的错误代码则表示错误出现在link阶段\n\nLink阶段，主文件调用了函数，即使它没有被实际使用，也会检错\n但当你在其调用前写下static这个词（静态），意味着这个东西只被声明在这个翻译单元中，它对其他的obj文件都不可见。若它在此文件没有被实际调用，将不会得到任何link错误，但他被调用时自然会检错\n\n出现多个一样的函数时，link也会告诉你它不知道要链哪个，所以注意使用\n\n类似static，在前面加一个Inline（内联）的意思是：建议编译器在调用函数的时候直接展开函数体→获取实际函数体并将函数调用替换为函数体，其实是重复调用函数转为重复调用代码，算是节省栈内存的重复消耗","tags":["总结","课报","C++"]},{"title":"C语言基础/1.0指针","url":"/2025/11/10/C语言基础-1-0指针/"},{"title":"密码相关算法/1.1欧几里得算法_贝祖定理_拓展欧几里得算法","url":"/2025/11/09/密码相关算法-1-1欧几里得算法-贝祖定理-拓展欧几里得算法/"},{"title":"密码前置数学/1.0模运算","url":"/2025/11/09/密码前置数学-1-0模运算/"},{"title":"密码基础/1.0古典密码","url":"/2025/11/09/密码基础-1-0古典密码/"},{"title":"初见二进制/汇编/1.5堆栈提升_堆栈图","url":"/2025/11/09/初见二进制-汇编-1-5堆栈提升-堆栈图/"},{"title":"初见二进制/汇编/1.4标志寄存器_JCC","url":"/2025/11/09/初见二进制-汇编-1-4标志寄存器-JCC/","content":"## 根据[教程](https://www.bilibili.com/video/BV1w54y1y7Di?spm_id_from=333.788.videopod.episodes&vd_source=6c7f9b089a676f27a9991651bb982255&p=6)视频，以下均以32位计算机为例\n\nPush的时候是立即数就永远-4\nPush 寄存器时，al（八位），不行\nPush ax（16位） 可以，会-2\nPush32位寄存器/容器，会-4\n也可以push一块内存（dword），把这内存的值push到目标位置（同样-4）\nPush word，则-2\nPush的是跟容器的宽度一样的，同样内存也不能push八位\n\nPop同理无8位，按照宽度pop，ax就+2.....\n\n### 堆栈平衡\nPushad指令\n把8个通用寄存器的值存到内存（堆栈）去了\nPopad指令\n把刚刚pushad的值又放回去了（你用pushad折腾完了想恢复原来的模样就popad一下）\n\n#### 所需知识\n\nPE结构\n\n下断点\nBp xxx→让xxx一执行的时候就断下来，下断点了\n\nWin32  Api\n\n什么是函数调用\n\n熟悉堆栈，画堆栈图\n栈顶最开始存储的是调用这个函数的时候函数的返回地址，follow过去看call的位置，看函数在哪调用的\n\nCall  jcc 标志寄存器\nJe看0/1，0就没跳\nCmp （compare比较）\nJcc指令由标志寄存器控制，JE→由Z控制，改后面的0/1就可以控制是否运行\n或直接把je改成jmp保存就跳到那边比较方便\n\n## 标志寄存器（EFL）\n\n标色的位无法控制是默认的\n研究这种先确定宽度\nELF一般都给你拆好了，但自己也要会看\nEg：ELF是202，→0010 0000 0010，你看这里的CF对应最后一个位，0.然后倒二个是默认的1，P位是0，P后面一位默认0.....\n\n1.进位标志寄存器CF（对应整个标志寄存器最后一个值）C  \nC看的是最高位有没有进位，不是数据的最低位！！！\n然后再看最高位是否产生进位借位，最高位由数据宽度决定。\nEg：\n对于55550000\nmov al，0xFF\nAdd al，1\n然后此时C会从0变成1，放C那边了，因为al是8位，此时并没有改变到原本值的数字！对应寄存器还是显示55550000（所以要说确定数据宽度）\n\n2.奇偶标志寄存器PF\n用来反映结果里（转成二进制后）1的个数，也就是1的个数的奇偶性，1为偶数个就是1，奇数个就是0\n\n3.辅助进位标志AF\n32位宽转换到16进制，如FFFFFFFF，它看什么，此时看FFFFFFFF标注的那一位是否向前进位，若进则变为1\n16位时候，FFFF；8位时候，FF\n\n4.零标志ZF\n用来反映运算结果是否为0，它变成1则表示你的计算结果是0！！\nMov这种就不算运算了，不改寄存器！！\nXor，sub\n清零可以xor自己！且影响标志位Z\n\n\n5.符号标志SF\n反映运算结果的符号位，运算结果与最高位相同（二进制，对应宽度最高位）\n\n6.溢出标志OF\n同样是以自己角度定义，所以加出来值不会变，变得是我们看待它的方式\nC位溢出\n做无符号运算时最应该关注的寄存器是C！因为此运算主要改变的是C，所以我们看c相当于看无符号有没有溢出，以此为标志，以下同理\t\nO位溢出\n有符号运算就看OF这个寄存器\n\n在这种表达下，一个正数加一个负数永远不会溢出！！\n正正相加结果负数/负负相加结果正数 则溢出！\n此时OF是1\n\nC O都溢出也有可能。\n\n\n\n### 指令\n\nADC（carry）指令：带进位加法\n两边不能同时内存，且宽度要一样\n\nSBB（borrow）：带借位减法\n同上\n\nXCHG：交换数据\n同上，且不能是立即数\n\nMOVS：移动数据，内存-内存，前后宽一样\n后面值取相应位到前面，可写为movsd，代表一次四字节，以此类比其他\n注意，移完栈top/base会各加相应4或2等等，取决于字节\n\n方向位寄存器DF（direction）\n0则加（正方向）改变地址栈针这样\n1则减（负方向）\n\nSTOS：将AL/AX/EAX的值存到[EDI]指定的内存单元\n一定要写ES:[EDI]\n向EDI存多少，由前面要求的字，字节等决定，EDI的增长方向由D决定\n\nREP（repeat，重复）：按计数寄存器ECX中指定的次数重复执行后面写的指令（注意是十六进制的数字，记得换算，例如10是16）","tags":["总结","汇编","课报"]},{"title":"初见二进制/汇编/1.3栈的初步认识_堆栈","url":"/2025/11/09/初见二进制-汇编-1-3栈的初步认识-堆栈/","content":"\n### 结合wiki来简单认识[栈](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/)","tags":["总结","汇编","课报"]},{"title":"初见二进制/汇编/1.2通用寄存器_认识指令_内存读写","url":"/2025/11/09/初见二进制-汇编-1-2通用寄存器-认识指令-内存读写/","content":"## 根据[教程](https://www.bilibili.com/video/BV1w54y1y7Di?spm_id_from=333.788.videopod.episodes&vd_source=6c7f9b089a676f27a9991651bb982255&p=6)视频，以下均以32位计算机为例\n\n#  一.通用寄存器（32位计算机）\n\n\n| 32位 | 16位 | 8位低↓高 | 编号 |\n| --- | --- | --- | --- |\n| EAX | AX |  AL | 0 |\n| ECX | CX | CL | 1 |\n| EDX | DX | DL | 2 |\n| EBX | BX | BL | 3 |\n| ESP | SP |  AH | 4 |\n| EBP | BP | CH | 5 |\n| ESI | SI | DH | 6 |\n| EDI | DI | BH | 7 |\n\n### ps：eip显示的是当前程序运行处\n`其它寄存器主要用途在此先不做介绍`\n\n为何分出不同位？\n减小不必要的损耗，8位能表示的就不必用32位表示。\n \n## 寄存器结构\n\n| 31 | 15 | 7 | 0 |\n| --- | --- | --- | --- |\n| EAX\t | AX | AH | AL |\n| ECX\t | CX | CH | CL |\n| EDX\t | DX | DH | DL |\n| EBX \t| BX | BH | BL |\n| ESP \t| SP |   |  |\n| EBP \t| BP | |  |\n| ESI \t| SI |  |  |\n| EDI \t| DI |  |  |\n\n\n\n# 二.常用汇编指令\n\n`r代表寄存器，m代表相应内存空间,imm代表相应位的立即数（一般16进制）`\n\n`说几位就几位，不够会补0，溢出会覆盖等等`\n\n`数溢出时，只从最低位开始存，多余被去除`\n\n## 1.mov\n\n#### 实质：操作码+操作数\n\t目标操作数：立即数，通用寄存器，段寄存器等等\n\t源操作数：同上\n\t\n\t在不搞小动作的情况下，操作数的宽度一般要一样，源操作数和目标操作数不为同一单元\n\n### 用法：\n\tmov 目标操作数，源操作数\n\n### 语法：\n\t目标操作数可为：\n\t\t\n\t\t1.r/m8(16,32),r8(16,32)\t  \n\t\t2.r8(16,32),r/m8(16,32)\n\t\t3.r8(16,32),imm8(16,32)\n\n\n## 2.add\n\n\n\n## 3.sub\n\n### 4.and\n\n### 5.or\n\n### 6.xor\n\n### 7.not\n\n\n# 三.内存\n\n简要介绍\n\n## 1.内存格式\n\n## 2.读写内存\n\n## 3.内存寻址\n\n","tags":["总结","汇编","课报"]},{"title":"初见二进制/汇编/1.1数据宽度_逻辑运算","url":"/2025/11/08/初见二进制-汇编-1-1数据宽度-逻辑运算/","content":"## 根据[教程](https://www.bilibili.com/video/BV1w54y1y7Di?spm_id_from=333.788.videopod.episodes&vd_source=6c7f9b089a676f27a9991651bb982255&p=6)视频，以下均以32位计算机为例\n\n# 一.数据宽度\n\n4位→可表示1位16进制0至F，以此类推。\n8位→2位16,00至FF\n16位→4位16,0000至FFFF\n32位→8位16,00000000至FFFFFFFF\n\n人为定义有/无符号\n\n0 1 2 3 4 5 6 7 8 9 A B C D E F\n每个数怎么表示是可以定义来的，如`顺序定义为0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15`或`补码定义0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1`此处不做详解\n\n”1开头为负数“的理解则代表后半部分能表示的数以一开头，而刚好此部分全被定义为负数。\n\n## 简单了解计量单位\n\n| 英文 | 中文 | 换算关系 |\n| --- | --- | --- |\n| BIT | 位 | 基础构成单元,一般以二进制呈现，为0或1 |\n| BYTE | 字节 | 1字节=8位 |\n| WORD | 字 | 此情况下1字通常为16位，即为2字节 |\n| DWORD | 双字 | 1字*2，通常为4字节 |\n\n\n# 二.逻辑运算\n\n| 英文 | 中文 | 符号 | 用途 |\n| --- | --- | --- | --- |\n| OR | 或 |  \"|\" | 置1 |\n| AND | 与 | & | 置0/进位 |\n| XOR | 异或 | ^ | 位加法，实质2的模运算，加密 |\n| NOT | 非 | ! | 翻转 |\n\n## 以4位为例\n\n### 1.计算2+3 \n容器：\nX：0010(2)\nY：0011(3)\n\n对每位:\n\t0010\n ^\t0011\n\t0001\n` R：0001 `\n\n进位:\n\t0010\n &\t0011\n\t0010\n` 同时0010<<1==0100(左移1位) `\n\t此时0100！=0000，所以继续运算\n \t\nR→X:0001\nY:0100\n\n对每位:\n\t0001\n  ^\t0100\n\t0101\n` R：0101 `\n\n进位:\n\t0001\n &\t0100\n\t0000\n` 同时0000<<1==0000(左移1位),此操作后仍为0则计算完毕，此时R的0101即为结果 `\n\n##### 所以2+3=5（0101）\n\n\n\n### 2.计算2-3 \n\n同理，X:0010\nY:0011→（进行补码运算，模16）1101\n\n对每位:\n\t0010\n  ^\t1101\n\t1111\n` R：1111 `\n\n进位:\n\t0010\n &\t1101\n\t0000\n` 同时0000<<1==0000(左移1位)，此操作后进位计算完毕 `\n\n##### 所以2-3=-1（1111为补码表示，对应原码-1）\n\n\n\n### 3.如何获取某value的第N位？ \n\n  利用&操作置0：\n\t10001111\n  &\t00001000\n\t00001000\n\n\n### 4.利用xor加密\n\n\t明：2015\n\tkey：54\n\n加密过程：\n   00100000(取20的8位明文为例)\n^01010100(key)\n  01110100(密文）\n\n解密过程：\n   01110100(key)\n^01010100(密文)\n  00100000(明文)\n\n\n## 汇编语言\n\n`mov`\n\n``` js\n//将2赋值给eax寄存器\nmov eax,2\n```\n","tags":["总结","汇编","课报"]},{"title":"ABOUT ME, LXIOS","url":"/2025/10/19/ABOUT-ME-LXIOS/","content":"### 这里是一只苦逼大学牲的博客，你可以称呼我灼心或者地瓜，当然，正经名字是Lxios，随你喜好就行\n## 目前专注于ctf二进制，密码以及超级计算机相关知识的学习，会不定期更新一些学习周报，或者发布一些日常心得等等\n\n# blog仍在搭建ing","tags":["hexo","萌新","喵喵喵"]},{"url":"/index.html"},{"title":"tags","url":"/tags/index.html"},{"title":"categories","url":"/categories/index.html"},{"title":"about","url":"/about/index.html"},{"title":"Notes","url":"/notes/index.html"}]